/*
生成窗口最大值数组
有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。
例如，数组为[4,3,5,4,3,3,6,7]，窗口大小为3时：

[4 3 5] 4 3 3 6 7 窗口中最大值为5
4 [3 5 4] 3 3 6 7 窗口中最大值为5
4 3 [5 4 3] 3 6 7 窗口中最大值为5
4 3 5 [4 3 3] 6 7 窗口中最大值为4
4 3 5 4 [3 3 6] 7 窗口中最大值为6
4 3 5 4 3 [3 6 7] 窗口中最大值为7

如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值。
请实现一个函数，给定一个数组arr，窗口大小w。返回一个长度为
n-w+1的数组res,res[i]表示每一种窗口状态下的最大值。
以本题为例，结果应该返回[5,5,5,4,6,7]。


解题思路：做一个双端队列，从左到右遍历数组，将数组当前元素的下标入队列尾部，并保证入队列时当前元素总比队尾表示的下标值表示的元素小，
不满足则踢掉队尾元素再比较，直到满足了，才将当前元素的下表加入队尾(即保证队列是严格从大到小排列)。检查当前元素的下标，
以此下标为窗口末端的窗口前段下标值是不是大于队列列首表示的下标值，若大于则不断踢掉队首元素（因为窗口过期了），直到小于等于了，
直接输出队首下标代表的元素值
*/

#include <iostream>
#include <deque>

using namespace std;

int main()
{
	int N, w;
	deque<int> _deq;
	cin >> N >> w;//1 <= w <= N
	int arr[N];
	for(int i = 0; i < N; i++) cin >> arr[i];
	for(int i = 0; i < N; i++)
	{
		for(int j = _deq.size() - 1; j >= 0; j--)
		{
			if(arr[_deq[j]] <= arr[i]) _deq.pop_back();
			else break;
		}
		_deq.push_back(i);
		if(i - (w - 1) >= 0)
		{
			for(int j = 0; j < _deq.size(); j++)
			{
				if(_deq[j] < i - (w - 1)) _deq.pop_front();
				else break;
			}
			cout << arr[_deq[0]] << endl;
		}
	}
	return 0;
} 
